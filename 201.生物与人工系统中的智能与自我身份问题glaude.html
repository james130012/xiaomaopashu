<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SFT记忆，RL泛化：基础模型后训练的比较研究分析</title>
    <script src="https://unpkg.com/mathjs@11.8.0/lib/browser/math.js"></script>
    <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <style>
        body {
            font-family: "Microsoft YaHei", sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #1a5276;
            text-align: center;
        }
        h2 {
            color: #2874a6;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        h3 {
            color: #3498db;
        }
        .chart-container {
            width: 100%;
            height: 400px;
            margin: 30px 0;
            position: relative;
        }
        .visualization {
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            background-color: #f9f9f9;
            position: relative;
        }
        .key-point {
            background-color: #e8f4fc;
            padding: 15px;
            border-left: 5px solid #3498db;
            margin: 15px 0;
        }
        figcaption {
            text-align: center;
            font-style: italic;
            margin-top: 10px;
        }
        blockquote {
            margin: 20px 0;
            padding: 10px 20px;
            background-color: #f8f9fa;
            border-left: 5px solid #ccc;
        }
        .chart-controls {
            text-align: center;
            margin-top: 10px;
        }
        .play-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        .play-btn:hover {
            background-color: #2980b9;
        }
        .play-btn.playing {
            background-color: #e74c3c;
        }
        .play-btn.playing:hover {
            background-color: #c0392b;
        }
        @keyframes cardFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(180deg); }
            100% { transform: rotateY(360deg); }
        }
        @keyframes pathTrace {
            0% { stroke-dashoffset: 1000; }
            100% { stroke-dashoffset: 0; }
        }
        .animate-card {
            animation: cardFlip 1.5s ease-in-out;
        }
        .agent-move {
            transition: all 2s ease-in-out;
        }
    </style>
</head>
<body>
    <h1>SFT记忆，RL泛化：基础模型后训练的比较研究分析</h1>
    
    <h2>1. 研究背景与目标</h2>
    <p>在人工智能领域，特别是大型语言模型（Large Language Models, LLMs）和视觉语言模型（Vision-Language Models, VLMs）的发展中，后训练技术（post-training）占据着至关重要的位置。其中，监督式微调（Supervised Fine-Tuning, SFT）和强化学习（Reinforcement Learning, RL）是两种最常用的后训练方法。然而，这两种方法对模型泛化能力的影响一直缺乏系统性的比较研究。</p>
    
    <p>Chu、Zhai等人在这篇研究中提出了一个重要问题：SFT和RL是倾向于记忆训练数据，还是学习可泛化的原则？为了解答这个问题，研究团队设计了两个测试环境：</p>
    
    <ol>
        <li><strong>GeneralPoints</strong>：一个算术推理卡牌游戏，用于评估文本规则泛化能力</li>
        <li><strong>V-IRL</strong>：一个现实世界导航环境，用于评估视觉和空间推理能力</li>
    </ol>
    
    <p>这项研究的主要目标是比较SFT和RL在分布内（in-distribution）和分布外（out-of-distribution）数据上的表现，揭示它们各自在记忆与泛化方面的特性。</p>

    <div class="key-point">
        <p>核心问题：SFT和RL在后训练过程中，哪种方法更有利于模型的泛化能力，哪种方法更倾向于简单记忆训练数据？</p>
    </div>

    <h2>2. 研究方法与实验设计</h2>
    
    <h3>2.1 基础模型与训练框架</h3>
    <p>研究使用Llama-3.2-Vision-11B作为基础模型，按照标准的RL4VLM和RLHF流程，首先对模型进行SFT初始化，然后分别进行SFT和RL的计算规模扩展。实验采用多步RL框架，并使用顺序修订（sequential revision）公式化，允许模型识别并纠正自身错误。</p>
    
    <p>具体来说，研究定义了状态空间\(S\)、动作空间\(A\)和验证器（verifier）\(VER\)：</p>
    
    <p>对于纯语言模型（LLM）：\(S := V^m\)，对于视觉语言模型（VLM）：\(S := V^m \times O\)，其中\(V\)是词汇空间，\(O\)是RGB图像空间。</p>
    
    <div class="chart-container">
        <canvas id="trainingFramework"></canvas>
        <div class="chart-controls">
            <button class="play-btn" id="trainingFrameworkBtn">播放动画</button>
        </div>
    </div>

    <h3>2.2 实验环境设计</h3>
    
    <h4>2.2.1 GeneralPoints环境</h4>
    <p>GeneralPoints是基于Points24环境设计的，任务是使用四张卡牌的数值恰好一次，通过四则运算得到目标数字（默认为24）。这个环境有两个变体：</p>
    <ul>
        <li>GP-L：纯文本描述卡牌</li>
        <li>GP-VL：以图像形式展示卡牌</li>
    </ul>
    
    <p>为了研究模型对规则的泛化能力，研究者设计了规则变体，包括：</p>
    <ul>
        <li>规则1：'J'、'Q'、'K'均记为'10'</li>
        <li>规则2：'J'、'Q'、'K'分别记为'11'、'12'、'13'</li>
    </ul>
    
    <p>为了研究视觉泛化能力，研究使用了不同颜色的卡牌：</p>
    <ul>
        <li>训练：黑色花色（♠, ♣）</li>
        <li>测试：红色花色（♥, ♦）</li>
    </ul>
    
    <div class="visualization">
        <div id="generalPointsViz"></div>
        <div class="chart-controls">
            <button class="play-btn" id="generalPointsVizBtn">播放动画</button>
        </div>
        <figcaption>图1：GeneralPoints任务示例 - 使用四张卡牌计算目标数字24</figcaption>
    </div>

    <h4>2.2.2 V-IRL环境</h4>
    <p>V-IRL是一个现实世界导航环境，要求模型根据指令进行导航。同样有两个变体：</p>
    <ul>
        <li>V-IRL-L：纯文本描述</li>
        <li>V-IRL-VL：包含视觉语言输入</li>
    </ul>
    
    <p>为了研究规则泛化能力，研究者设计了两种不同的动作空间：</p>
    <ul>
        <li>绝对方向：{'north', 'northeast', 'east', 'southeast', 'south', 'southwest', 'west', 'northwest'}</li>
        <li>相对方向：{'left', 'right', 'slightly left', 'slightly right'}</li>
    </ul>
    
    <p>为了评估视觉泛化能力，研究在纽约市的路线上进行训练，而在全球不同城市的路线上进行测试。</p>
    
    <div class="visualization">
        <div id="virlViz"></div>
        <div class="chart-controls">
            <button class="play-btn" id="virlVizBtn">播放动画</button>
        </div>
        <figcaption>图2：V-IRL导航任务示例 - 模型需要根据指令和视觉输入进行导航</figcaption>
    </div>

    <h2>3. 主要研究发现</h2>
    
    <h3>3.1 规则泛化比较</h3>
    <p>研究结果清晰地表明，RL在规则泛化方面显著优于SFT。具体来说：</p>
    
    <ul>
        <li>在GP-L任务中，RL将OOD性能提高了+3.5%（11.5% → 15.0%）</li>
        <li>在V-IRL-L任务中，RL提高了+11.0%（80.8% → 91.8%）</li>
        <li>即使在增加了视觉识别挑战的VLM中，RL仍然保持了一致的性能提升：
            <ul>
                <li>GP-VL：+3.0%（11.2% → 14.2%）</li>
                <li>V-IRL-VL：+9.3%（35.7% → 45.0%）</li>
            </ul>
        </li>
    </ul>
    
    <p>相比之下，SFT在所有OOD评估任务中都表现出性能下降：</p>
    <ul>
        <li>GP-L：-8.1%（11.5% → 3.4%）</li>
        <li>V-IRL-L：-79.5%（80.8% → 1.3%）</li>
        <li>GP-VL：-5.6%（11.2% → 5.6%）</li>
        <li>V-IRL-VL：-33.2%（35.7% → 2.5%）</li>
    </ul>
    
    <div class="chart-container">
        <canvas id="ruleGeneralization"></canvas>
        <div class="chart-controls">
            <button class="play-btn" id="ruleGeneralizationBtn">播放动画</button>
        </div>
    </div>

    <div class="key-point">
        <p>关键发现：RL训练的模型能够学习通用规则并泛化到未见过的规则变体，而SFT倾向于记忆训练规则，无法泛化到分布外数据。</p>
    </div>

    <h3>3.2 视觉泛化比较</h3>
    <p>研究还发现，RL在视觉泛化任务上同样优于SFT：</p>
    
    <ul>
        <li>在GP-VL中，RL将视觉OOD性能提高了+17.6%（23.6% → 41.2%）</li>
        <li>在V-IRL-VL中，RL提高了惊人的+61.1%（16.7% → 77.8%）</li>
    </ul>
    
    <p>作为这一研究的副产品，研究团队的多轮RL方法在V-IRL小型基准测试上将最先进的性能提高了+33.8%（44.0% → 77.8%），凸显了RL的泛化能力。</p>
    
    <div class="chart-container">
        <canvas id="visualGeneralization"></canvas>
        <div class="chart-controls">
            <button class="play-btn" id="visualGeneralizationBtn">播放动画</button>
        </div>
    </div>

    <h3>3.3 RL改善视觉能力</h3>
    <p>研究者进一步在GP-VL环境中进行了额外的分析，发现：</p>
    <ul>
        <li>视觉识别准确率在很大程度上影响了整体性能</li>
        <li>扩大RL计算规模也提高了视觉识别准确率</li>
        <li>扩大SFT反而降低了视觉识别准确率和整体性能</li>
    </ul>
    
    <div class="chart-container">
        <canvas id="recognitionVsSuccess"></canvas>
        <div class="chart-controls">
            <button class="play-btn" id="recognitionVsSuccessBtn">播放动画</button>
        </div>
    </div>

    <h3>3.4 SFT在RL训练中的作用</h3>
    <p>尽管RL在泛化方面表现优于SFT，但研究发现SFT对有效的RL训练仍然非常重要。实验显示，如果没有SFT初始化，直接将RL应用于基础模型会失败。主要原因是：</p>
    <ul>
        <li>基础模型的指令遵循能力较差</li>
        <li>未经SFT的模型往往生成冗长、离题的回应</li>
        <li>这使得无法检索任务相关信息和奖励进行RL训练</li>
    </ul>
    
    <div class="key-point">
        <p>重要发现：SFT为RL训练提供了稳定的输出格式基础，使RL能够实现其性能增益。</p>
    </div>

    <h3>3.5 验证迭代的作用</h3>
    <p>研究还调查了验证迭代（verification iterations）数量对泛化能力的影响。结果表明，在相同的计算预算下，增加验证步骤数量能够提高RL的泛化能力：</p>
    <ul>
        <li>3步验证：+2.15%</li>
        <li>5步验证：+2.99%</li>
        <li>10步验证：+5.99%</li>
    </ul>
    <p>相比之下，只有1步验证的情况下，OOD性能提升仅为+0.48%。</p>
    
    <div class="chart-container">
        <canvas id="verificationIterations"></canvas>
        <div class="chart-controls">
            <button class="play-btn" id="verificationIterationsBtn">播放动画</button>
        </div>
    </div>

    <h2>4. 理论解释与理论意义</h2>
    
    <h3>4.1 为什么RL能够更好地泛化？</h3>
    <p>研究者提出，RL之所以能够实现更好的泛化，主要是因为它基于结果的奖励函数（outcome-based reward）。与SFT不同，RL不仅仅是模仿训练数据，而是学习最大化特定目标的策略。</p>
    
    <p>具体来说，RL通过以下方式促进泛化：</p>
    <ol>
        <li>探索更广泛的状态空间</li>
        <li>优化与任务目标直接相关的奖励信号</li>
        <li>通过试错学习发现解决问题的一般原则</li>
    </ol>
    
    <p>这使得RL训练的模型能够学习底层规则和模式，而不仅仅是记住特定示例。</p>

    <h3>4.2 SFT的局限性</h3>
    <p>相比之下，SFT的主要局限性在于：</p>
    <ol>
        <li>它直接优化模型以模仿训练数据</li>
        <li>没有明确的机制来识别和泛化底层原则</li>
        <li>在视觉任务中，SFT可能过度拟合推理标记而忽略识别标记</li>
    </ol>
    
    <p>这解释了为什么SFT在分布内数据上表现良好，但在分布外数据上表现不佳。</p>

    <h3>4.3 理论启示</h3>
    <p>这项研究为基础模型后训练提供了几个重要启示：</p>
    <ol>
        <li>在追求泛化能力时，RL应优先于SFT</li>
        <li>最佳的后训练策略可能是先进行SFT（稳定输出格式），再进行RL（增强泛化能力）</li>
        <li>增加验证迭代次数可以进一步提高RL的泛化能力</li>
        <li>对于多模态任务，RL不仅改善推理能力，还能增强视觉识别能力</li>
    </ol>
    
    <div class="key-point">
        <p>启示：SFT和RL在后训练中扮演不同但互补的角色 - SFT提供格式稳定性，RL提供泛化能力。</p>
    </div>

    <h2>5. 研究限制与未来方向</h2>
    
    <h3>5.1 研究限制</h3>
    <p>尽管这项研究提供了宝贵的见解，但也存在一些限制：</p>
    <ul>
        <li><strong>GP-VL上SFT的失败</strong>：研究观察到SFT在GP-VL上无法达到与RL相当的分布内性能。即使在进行了10多个不同学习率和可调组件的实验后，SFT仍未表现出与RL相似的增长趋势。</li>
        <li><strong>RL在极端情况下的局限性</strong>：当从过度拟合的SFT检查点开始时，RL无法恢复分布外性能。这表明RL在应用于极度欠拟合或过拟合的初始检查点时效果有限。</li>
    </ul>

    <h3>5.2 未来研究方向</h3>
    <p>基于这项研究的发现，以下几个方向值得进一步探索：</p>
    <ol>
        <li>开发能更好结合SFT和RL优势的混合后训练方法</li>
        <li>设计专门针对视觉识别能力的RL奖励函数</li>
        <li>探索为什么SFT在视觉任务中表现不佳的深层原因</li>
        <li>研究如何确定SFT和RL的最佳平衡点</li>
        <li>将研究扩展到更多样化的任务和更大规模的模型</li>
    </ol>

    <h2>6. 总结与结论</h2>
    <p>该研究通过系统比较SFT和RL在文本和视觉环境中的泛化能力，揭示了一个清晰的模式：<strong>SFT记忆，RL泛化</strong>。</p>
    
    <p>主要结论可以概括为：</p>
    <ol>
        <li>RL能够学习泛化的规则和原则，在分布外任务上表现良好</li>
        <li>SFT倾向于记忆训练数据，难以泛化到分布外场景</li>
        <li>在视觉任务中，RL还能提高模型的视觉识别能力</li>
        <li>SFT对于有效的RL训练仍然很重要，提供稳定的输出格式</li>
        <li>增加验证迭代次数可以进一步提高RL的泛化能力</li>
    </ol>
    
    <p>这些发现对于设计更强大、更通用的AI系统具有重要意义，特别是当这些系统需要在复杂、多模态任务中展示泛化能力时。</p>
    
    <blockquote>
        <p>"RL，特别是当基于结果的奖励进行训练时，在基于规则的文本和视觉环境中都能够泛化。相比之下，SFT倾向于记忆训练数据，在任何情况下都难以实现分布外泛化。"</p>
    </blockquote>

    <div class="key-point">
        <p>核心结论：在追求可泛化知识获取的复杂多模态任务中，RL展示出明显的优势，而SFT在提供稳定输出格式方面具有价值。</p>
    </div>

    <script>
        // 图1：训练框架可视化
        function createTrainingFramework() {
            const ctx = document.getElementById('trainingFramework').getContext('2d');
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['SFT', 'RL'],
                    datasets: [
                        {
                            label: '分布内泛化能力',
                            data: [0, 0],
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        },
                        {
                            label: '分布外泛化能力',
                            data: [0, 0],
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    animation: {
                        duration: 2000,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'SFT与RL训练效果比较',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '性能 (%)'
                            },
                            max: 100
                        }
                    }
                }
            });
            
            // 添加播放按钮功能
            const playBtn = document.getElementById('trainingFrameworkBtn');
            let isPlaying = false;
            let animationInterval;
            
            playBtn.addEventListener('click', function() {
                if (isPlaying) {
                    clearInterval(animationInterval);
                    playBtn.textContent = '播放动画';
                    playBtn.classList.remove('playing');
                    
                    // 重置数据
                    chart.data.datasets[0].data = [0, 0];
                    chart.data.datasets[1].data = [0, 0];
                    chart.update();
                } else {
                    playBtn.textContent = '停止动画';
                    playBtn.classList.add('playing');
                    
                    let step = 0;
                    const maxSteps = 50;
                    const targetData1 = [75, 90];
                    const targetData2 = [25, 65];
                    
                    animationInterval = setInterval(() => {
                        step++;
                        const progress = step / maxSteps;
                        
                        chart.data.datasets[0].data = [
                            Math.round(targetData1[0] * progress),
                            Math.round(targetData1[1] * progress)
                        ];
                        chart.data.datasets[1].data = [
                            Math.round(targetData2[0] * progress),
                            Math.round(targetData2[1] * progress)
                        ];
                        
                        chart.update();
                        
                        if (step >= maxSteps) {
                            clearInterval(animationInterval);
                            playBtn.textContent = '重新播放';
                        }
                    }, 40);
                }
                isPlaying = !isPlaying;
            });
            
            return chart;
        }

        // 图2：规则泛化比较
        function createRuleGeneralization() {
            const ctx = document.getElementById('ruleGeneralization').getContext('2d');
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['GP-L', 'V-IRL-L', 'GP-VL', 'V-IRL-VL'],
                    datasets: [
                        {
                            label: '初始模型',
                            data: [0, 0, 0, 0],
                            backgroundColor: 'rgba(200, 200, 200, 0.5)',
                            borderColor: 'rgba(200, 200, 200, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'SFT',
                            data: [0, 0, 0, 0],
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'RL',
                            data: [0, 0, 0, 0],
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    animation: {
                        duration: 2000,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '规则变体下的分布外性能比较',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '分布外成功率 (%)'
                            }
                        }
                    }
                }
            });
            
            // 添加播放按钮功能
            const playBtn = document.getElementById('ruleGeneralizationBtn');
            let isPlaying = false;
            let animationInterval;
            
            playBtn.addEventListener('click', function() {
                if (isPlaying) {
                    clearInterval(animationInterval);
                    playBtn.textContent = '播放动画';
                    playBtn.classList.remove('playing');
                    
                    // 重置数据
                    chart.data.datasets[0].data = [0, 0, 0, 0];
                    chart.data.datasets[1].data = [0, 0, 0, 0];
                    chart.data.datasets[2].data = [0, 0, 0, 0];
                    chart.update();
                } else {
                    playBtn.textContent = '停止动画';
                    playBtn.classList.add('playing');
                    
                    let step = 0;
                    const maxSteps = 50;
                    const target1 = [11.5, 80.8, 11.2, 35.7];
                    const target2 = [3.4, 1.3, 5.6, 2.5];
                    const target3 = [15.0, 91.8, 14.2, 45.0];
                    
                    animationInterval = setInterval(() => {
                        step++;
                        const progress = step / maxSteps;
                        
                        chart.data.datasets[0].data = target1.map(val => val * progress);
                        chart.data.datasets[1].data = target2.map(val => val * progress);
                        chart.data.datasets[2].data = target3.map(val => val * progress);
                        
                        chart.update();
                        
                        if (step >= maxSteps) {
                            clearInterval(animationInterval);
                            playBtn.textContent = '重新播放';
                        }
                    }, 40);
                }
                isPlaying = !isPlaying;
            });
            
            return chart;
        }

        // 图3：视觉泛化比较
        function createVisualGeneralization() {
            const ctx = document.getElementById('visualGeneralization').getContext('2d');
            const chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['GP-VL', 'V-IRL-VL'],
                    datasets: [
                        {
                            label: '初始模型',
                            data: [0, 0],
                            backgroundColor: 'rgba(200, 200, 200, 0.5)',
                            borderColor: 'rgba(200, 200, 200, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'SFT',
                            data: [0, 0],
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'RL',
                            data: [0, 0],
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        },
                        {
                            label: '先前SOTA',
                            data: [0, 0],
                            backgroundColor: 'rgba(255, 206, 86, 0.5)',
                            borderColor: 'rgba(255, 206, 86, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    animation: {
                        duration: 2000,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '视觉变体下的分布外性能比较',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '视觉分布外成功率 (%)'
                            },
                            max: 100
                        }
                    }
                }
            });
            
            // 添加播放按钮功能
            const playBtn = document.getElementById('visualGeneralizationBtn');
            let isPlaying = false;
            let animationInterval;
            
            playBtn.addEventListener('click', function() {
                if (isPlaying) {
                    clearInterval(animationInterval);
                    playBtn.textContent = '播放动画';
                    playBtn.classList.remove('playing');
                    
                    // 重置数据
                    chart.data.datasets[0].data = [0, 0];
                    chart.data.datasets[1].data = [0, 0];
                    chart.data.datasets[2].data = [0, 0];
                    chart.data.datasets[3].data = [0, 0];
                    chart.update();
                } else {
                    playBtn.textContent = '停止动画';
                    playBtn.classList.add('playing');
                    
                    let step = 0;
                    const maxSteps = 50;
                    const target1 = [23.6, 16.7];
                    const target2 = [13.7, 11.1];
                    const target3 = [41.2, 77.8];
                    const target4 = [0, 44.0];
                    
                    animationInterval = setInterval(() => {
                        step++;
                        const progress = step / maxSteps;
                        
                        chart.data.datasets[0].data = target1.map(val => val * progress);
                        chart.data.datasets[1].data = target2.map(val => val * progress);
                        chart.data.datasets[2].data = target3.map(val => val * progress);
                        chart.data.datasets[3].data = target4.map(val => val * progress);
                        
                        chart.update();
                        
                        if (step >= maxSteps) {
                            clearInterval(animationInterval);
                            playBtn.textContent = '重新播放';
                        }
                    }, 40);
                }
                isPlaying = !isPlaying;
            });
            
            return chart;
        }

        // 图4：识别准确率与成功率关系
        function createRecognitionVsSuccess() {
            const ctx = document.getElementById('recognitionVsSuccess').getContext('2d');
            
            // 创建初始空数据
            const emptyData = {
                datasets: [
                    {
                        label: 'SFT - 分布内',
                        data: [],
                        backgroundColor: 'rgba(255, 99, 132, 0.5)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        pointRadius: 8,
                    },
                    {
                        label: 'SFT - 分布外',
                        data: [],
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        borderColor: 'rgba(255, 99, 132, 0.5)',
                        pointRadius: 8,
                    },
                    {
                        label: 'RL - 分布内',
                        data: [],
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointRadius: 8,
                    },
                    {
                        label: 'RL - 分布外',
                        data: [],
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 0.5)',
                        pointRadius: 8,
                    }
                ]
            };
            
            // 完整数据
            const fullData = {
                datasets: [
                    {
                        label: 'SFT - 分布内',
                        data: [
                            {x: 30, y: 50},
                            {x: 20, y: 60},
                            {x: 25, y: 55},
                            {x: 15, y: 70},
                            {x: 10, y: 65}
                        ],
                        backgroundColor: 'rgba(255, 99, 132, 0.5)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        pointRadius: 8,
                    },
                    {
                        label: 'SFT - 分布外',
                        data: [
                            {x: 10, y: 35},
                            {x: 5, y: 30},
                            {x: 8, y: 25},
                            {x: 3, y: 20},
                            {x: 2, y: 15}
                        ],
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        borderColor: 'rgba(255, 99, 132, 0.5)',
                        pointRadius: 8,
                    },
                    {
                        label: 'RL - 分布内',
                        data: [
                            {x: 35, y: 75},
                            {x: 40, y: 80},
                            {x: 45, y: 85},
                            {x: 50, y: 90},
                            {x: 60, y: 95}
                        ],
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointRadius: 8,
                    },
                    {
                        label: 'RL - 分布外',
                        data: [
                            {x: 20, y: 55},
                            {x: 25, y: 65},
                            {x: 30, y: 75},
                            {x: 35, y: 85},
                            {x: 40, y: 90}
                        ],
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 0.5)',
                        pointRadius: 8,
                    }
                ]
            };
            
            const chart = new Chart(ctx, {
                type: 'scatter',
                data: emptyData,
                options: {
                    responsive: true,
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'GP-VL中识别准确率与成功率的关系',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '成功率 (%)'
                            },
                            min: 0,
                            max: 100
                        },
                        y: {
                            title: {
                                display: true,
                                text: '识别准确率 (%)'
                            },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
            
            // 添加播放按钮功能
            const playBtn = document.getElementById('recognitionVsSuccessBtn');
            let isPlaying = false;
            let currentPoint = 0;
            let animationInterval;
            
            playBtn.addEventListener('click', function() {
                if (isPlaying) {
                    clearInterval(animationInterval);
                    playBtn.textContent = '播放动画';
                    playBtn.classList.remove('playing');
                    
                    // 重置数据
                    chart.data = JSON.parse(JSON.stringify(emptyData));
                    chart.update();
                    currentPoint = 0;
                } else {
                    playBtn.textContent = '停止动画';
                    playBtn.classList.add('playing');
                    
                    animationInterval = setInterval(() => {
                        // 每个数据集添加一个点
                        for (let i = 0; i < chart.data.datasets.length; i++) {
                            if (currentPoint < fullData.datasets[i].data.length) {
                                chart.data.datasets[i].data.push(fullData.datasets[i].data[currentPoint]);
                            }
                        }
                        
                        chart.update();
                        currentPoint++;
                        
                        if (currentPoint >= 5) {
                            clearInterval(animationInterval);
                            playBtn.textContent = '重新播放';
                        }
                    }, 500);
                }
                isPlaying = !isPlaying;
            });
            
            return chart;
        }

        // 图5：验证迭代的影响
        function createVerificationIterations() {
            const ctx = document.getElementById('verificationIterations').getContext('2d');
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['1步验证', '3步验证', '5步验证', '10步验证'],
                    datasets: [
                        {
                            label: '分布内性能增长',
                            data: [0, 0, 0, 0],
                            backgroundColor: 'rgba(54, 162, 235, 0.5)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 2,
                            tension: 0.3
                        },
                        {
                            label: '分布外性能增长',
                            data: [0, 0, 0, 0],
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 2,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    animation: {
                        duration: 2000,
                        easing: 'easeOutQuart'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: '验证迭代次数对性能增长的影响',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '性能增长 (%)'
                            }
                        }
                    }
                }
            });
            
            // 添加播放按钮功能
            const playBtn = document.getElementById('verificationIterationsBtn');
            let isPlaying = false;
            let animationInterval;
            
            playBtn.addEventListener('click', function() {
                if (isPlaying) {
                    clearInterval(animationInterval);
                    playBtn.textContent = '播放动画';
                    playBtn.classList.remove('playing');
                    
                    // 重置数据
                    chart.data.datasets[0].data = [0, 0, 0, 0];
                    chart.data.datasets[1].data = [0, 0, 0, 0];
                    chart.update();
                } else {
                    playBtn.textContent = '停止动画';
                    playBtn.classList.add('playing');
                    
                    const targetData1 = [4, 6, 8, 12];
                    const targetData2 = [0.48, 2.15, 2.99, 5.99];
                    
                    let idx = 0;
                    
                    animationInterval = setInterval(() => {
                        if (idx < 4) {
                            // 逐个点显示
                            chart.data.datasets[0].data[idx] = targetData1[idx];
                            chart.data.datasets[1].data[idx] = targetData2[idx];
                            chart.update();
                            idx++;
                        } else {
                            clearInterval(animationInterval);
                            playBtn.textContent = '重新播放';
                        }
                    }, 700);
                }
                isPlaying = !isPlaying;
            });
            
            return chart;
        }

        // 创建GeneralPoints任务可视化
        function createGeneralPointsViz() {
            const container = document.getElementById('generalPointsViz');
            
            const html = `
                <div style="display: flex; justify-content: center; align-items: center; gap: 20px;">
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div class="card" style="width: 80px; height: 120px; border: 2px solid #000; border-radius: 10px; display: flex; justify-content: center; align-items: center; background-color: white; font-size: 24px; position: relative; transform-style: preserve-3d;">
                            <div style="position: absolute; top: 5px; left: 5px; font-size: 20px;">5</div>
                            <div style="position: absolute; bottom: 5px; right: 5px; font-size: 20px;">5</div>
                            <div style="color: #d40000; font-size: 32px;">♦</div>
                        </div>
                        <p>5♦</p>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div class="card" style="width: 80px; height: 120px; border: 2px solid #000; border-radius: 10px; display: flex; justify-content: center; align-items: center; background-color: white; font-size: 24px; position: relative; transform-style: preserve-3d;">
                            <div style="position: absolute; top: 5px; left: 5px; font-size: 20px;">4</div>
                            <div style="position: absolute; bottom: 5px; right: 5px; font-size: 20px;">4</div>
                            <div style="color: #d40000; font-size: 32px;">♦</div>
                        </div>
                        <p>4♦</p>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div class="card" style="width: 80px; height: 120px; border: 2px solid #000; border-radius: 10px; display: flex; justify-content: center; align-items: center; background-color: white; font-size: 24px; position: relative; transform-style: preserve-3d;">
                            <div style="position: absolute; top: 5px; left: 5px; font-size: 20px;">10</div>
                            <div style="position: absolute; bottom: 5px; right: 5px; font-size: 20px;">10</div>
                            <div style="color: #000; font-size: 32px;">♣</div>
                        </div>
                        <p>10♣</p>
                    </div>
                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <div class="card" style="width: 80px; height: 120px; border: 2px solid #000; border-radius: 10px; display: flex; justify-content: center; align-items: center; background-color: white; font-size: 24px; position: relative; transform-style: preserve-3d;">
                            <div style="position: absolute; top: 5px; left: 5px; font-size: 20px;">7</div>
                            <div style="position: absolute; bottom: 5px; right: 5px; font-size: 20px;">7</div>
                            <div style="color: #000; font-size: 32px;">♣</div>
                        </div>
                        <p>7♣</p>
                    </div>
                </div>
                <div style="margin-top: 20px; text-align: center;">
                    <p style="font-weight: bold;">问题：使用四张卡牌计算24</p>
                    <div id="solutions" style="display: flex; justify-content: center; gap: 10px; margin-top: 10px;">
                        <div id="solution1" style="border: 1px solid #ccc; padding: 10px; border-radius: 5px; background-color: #f8f8f8; opacity: 0; transition: opacity 0.5s ease;">
                            <p>解法1: 10+7+4+5 = 26</p>
                            <p style="color: red;">错误！结果不等于24</p>
                        </div>
                        <div id="solution2" style="border: 1px solid #ccc; padding: 10px; border-radius: 5px; background-color: #f8f8f8; opacity: 0; transition: opacity 0.5s ease;">
                            <p>解法2: (7-4)*10-6 = 24</p>
                            <p style="color: red;">错误！使用了错误数字6</p>
                        </div>
                        <div id="solution3" style="border: 1px solid #ccc; padding: 10px; border-radius: 5px; background-color: #f8f8f8; opacity: 0; transition: opacity 0.5s ease;">
                            <p>解法3: (7-5)*10+4 = 24</p>
                            <p style="color: green;">正确！</p>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // 添加播放按钮功能
            const playBtn = document.getElementById('generalPointsVizBtn');
            let isPlaying = false;
            
            playBtn.addEventListener('click', function() {
                if (isPlaying) {
                    playBtn.textContent = '播放动画';
                    playBtn.classList.remove('playing');
                    
                    // 重置动画
                    document.querySelectorAll('.card').forEach(card => {
                        card.classList.remove('animate-card');
                    });
                    
                    document.getElementById('solution1').style.opacity = 0;
                    document.getElementById('solution2').style.opacity = 0;
                    document.getElementById('solution3').style.opacity = 0;
                } else {
                    playBtn.textContent = '停止动画';
                    playBtn.classList.add('playing');
                    
                    // 逐个翻转卡片
                    const cards = document.querySelectorAll('.card');
                    cards.forEach((card, index) => {
                        setTimeout(() => {
                            card.classList.add('animate-card');
                        }, index * 300);
                    });
                    
                    // 依次显示解法
                    setTimeout(() => {
                        document.getElementById('solution1').style.opacity = 1;
                    }, 1500);
                    
                    setTimeout(() => {
                        document.getElementById('solution2').style.opacity = 1;
                    }, 2500);
                    
                    setTimeout(() => {
                        document.getElementById('solution3').style.opacity = 1;
                        playBtn.textContent = '重新播放';
                    }, 3500);
                }
                isPlaying = !isPlaying;
            });
        }

        // 创建V-IRL导航任务可视化
        function createVIRLViz() {
            const container = document.getElementById('virlViz');
            
            const html = `
                <div style="position: relative; width: 100%; height: 350px; background-color: #f0f0f0; border-radius: 10px; overflow: hidden;">
                    <!-- 地图背景 -->
                    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #e8e8e8;">
                        <!-- 街道 -->
                        <div style="position: absolute; top: 50%; left: 0; width: 100%; height: 40px; background-color: #aaa; transform: translateY(-50%);"></div>
                        <div style="position: absolute; top: 0; left: 50%; width: 40px; height: 100%; background-color: #aaa; transform: translateX(-50%);"></div>
                    </div>
                    
                    <!-- 标记点 -->
                    <div style="position: absolute; top: 30%; left: 30%; width: 25px; height: 25px; background-color: #4CAF50; border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;">A</div>
                    <div style="position: absolute; top: 30%; left: 70%; width: 25px; height: 25px; background-color: #2196F3; border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;">B</div>
                    <div style="position: absolute; top: 70%; left: 70%; width: 25px; height: 25px; background-color: #FFC107; border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;">C</div>
                    
                    <!-- 导航路径 -->
                    <svg style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#FF5722" />
                            </marker>
                        </defs>
                        <path id="navPath" d="M 30% 30% L 70% 30% L 70% 70%" stroke="#FF5722" stroke-width="3" fill="none" stroke-dasharray="5,5" marker-end="url(#arrowhead)" stroke-dashoffset="1000" />
                    </svg>
                    
                    <!-- 代理位置 -->
                    <div id="agent" style="position: absolute; top: 30%; left: 30%; width: 15px; height: 15px; background-color: #E91E63; border-radius: 50%; transform: translate(-50%, -50%);" class="agent-move"></div>
                    
                    <!-- 视觉观察 -->
                    <div id="observation" style="position: absolute; bottom: 10px; left: 10px; width: 150px; height: 100px; background-color: white; border: 1px solid #ccc; border-radius: 5px; overflow: hidden; opacity: 0; transition: opacity 0.5s ease;">
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTAgMTAwIj48cmVjdCB3aWR0aD0iMTUwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2YwZjBmMCIvPjxyZWN0IHg9IjIwIiB5PSIyMCIgd2lkdGg9IjQwIiBoZWlnaHQ9IjYwIiBmaWxsPSIjYmNiY2JjIi8+PHJlY3QgeD0iNzAiIHk9IjMwIiB3aWR0aD0iNjAiIGhlaWdodD0iNTAiIGZpbGw9IiNkZGRkZGQiLz48Y2lyY2xlIGN4PSIxMDAiIGN5PSI0MCIgcj0iMTAiIGZpbGw9IiMyMTk2RjMiLz48dGV4dCB4PSIxMDAiIHk9IjQ1IiBmb250LXNpemU9IjEwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjZmZmIj5CPC90ZXh0Pjwvc3ZnPg==" width="100%" height="100%" />
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;">
                    <p style="margin: 0; font-weight: bold;">导航指令：</p>
                    <p style="margin: 5px 0;">首先，向右转朝向东北方向，走一小段距离，直到下一个路口，那里你会在右侧看到The Dutch。接下来，向左急转面向西北方向。继续一段时间，直到下一个路口，那里Lola Taverna会在你的右侧。最后，稍微向右转面向东北方向，走一小段距离，直到你到达目的地Shuka，它会在你的右侧。</p>
                    <div id="navigationInfo" style="margin-top: 10px; display: flex; justify-content: space-between; opacity: 0; transition: opacity 0.5s ease;">
                        <div>
                            <p style="margin: 0; font-weight: bold;">观察：</p>
                            <p id="observationText" style="margin: 5px 0; color: #2196F3;">"看到The Dutch在我右侧。"</p>
                        </div>
                        <div>
                            <p style="margin: 0; font-weight: bold;">动作：</p>
                            <p id="actionText" style="margin: 5px 0; color: #E91E63;">"向西北方向左转。"</p>
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // 添加播放按钮功能
            const playBtn = document.getElementById('virlVizBtn');
            let isPlaying = false;
            
            // 定义途经的关键点
            const waypoints = [
                { top: '30%', left: '30%', observation: '"开始！"', action: '"向东北方向转。"' },
                { top: '30%', left: '70%', observation: '"看到The Dutch在我右侧。"', action: '"向西北方向左转。"' },
                { top: '70%', left: '70%', observation: '"看到Lola Taverna在我右侧。"', action: '"停止。"' }
            ];
            
            let currentWaypoint = 0;
            
            playBtn.addEventListener('click', function() {
                if (isPlaying) {
                    playBtn.textContent = '播放动画';
                    playBtn.classList.remove('playing');
                    
                    // 重置动画
                    document.getElementById('agent').style.top = '30%';
                    document.getElementById('agent').style.left = '30%';
                    document.getElementById('navPath').style.strokeDashoffset = '1000';
                    document.getElementById('observation').style.opacity = '0';
                    document.getElementById('navigationInfo').style.opacity = '0';
                    currentWaypoint = 0;
                    
                } else {
                    playBtn.textContent = '停止动画';
                    playBtn.classList.add('playing');
                    
                    // 路径动画
                    document.getElementById('navPath').style.transition = 'stroke-dashoffset 3s ease-in-out';
                    document.getElementById('navPath').style.strokeDashoffset = '0';
                    
                    // 显示观察窗口
                    setTimeout(() => {
                        document.getElementById('observation').style.opacity = '1';
                    }, 500);
                    
                    // 显示导航信息
                    setTimeout(() => {
                        document.getElementById('navigationInfo').style.opacity = '1';
                        document.getElementById('observationText').textContent = waypoints[0].observation;
                        document.getElementById('actionText').textContent = waypoints[0].action;
                    }, 1000);
                    
                    // 移动代理
                    animateAgentMovement();
                }
                isPlaying = !isPlaying;
            });
            
            function animateAgentMovement() {
                if (currentWaypoint >= waypoints.length - 1) {
                    playBtn.textContent = '重新播放';
                    return;
                }
                
                currentWaypoint++;
                const waypoint = waypoints[currentWaypoint];
                
                // 更新代理位置
                setTimeout(() => {
                    const agent = document.getElementById('agent');
                    agent.style.top = waypoint.top;
                    agent.style.left = waypoint.left;
                    
                    // 更新观察和动作文本
                    document.getElementById('observationText').textContent = waypoint.observation;
                    document.getElementById('actionText').textContent = waypoint.action;
                    
                    // 如果还有下一个点，继续移动
                    if (currentWaypoint < waypoints.length - 1) {
                        setTimeout(animateAgentMovement, 2000);
                    }
                }, 2000);
            }
        }

        // 页面加载后执行所有图表创建
        window.onload = function() {
            createTrainingFramework();
            createRuleGeneralization();
            createVisualGeneralization();
            createRecognitionVsSuccess();
            createVerificationIterations();
            createGeneralPointsViz();
            createVIRLViz();
            
            // MathJax重新渲染页面上的公式
            if (typeof MathJax !== 'undefined') {
                MathJax.typeset();
            }
        };
    </script>
</body>
</html>

